package joinaccept

import (
	"encoding/hex"
	"reflect"
	"testing"

	"github.com/tkiraly/lorawan/mhdr"
)

func TestNew(t *testing.T) {
	type args struct {
		Major       mhdr.MajorVersion
		appnonce    []byte
		netid       []byte
		devaddr     []byte
		rx1droffset byte
		rx2datarate byte
		rxdelay     byte
		cflist      []uint32
		key         []byte
	}
	tests := []struct {
		name string
		args args
		want JoinAccept
	}{
		{"basic",
			args{
				Major:       mhdr.LoRaWANR1MajorVersion,
				appnonce:    []byte{0x24, 0x63, 0x61},
				netid:       []byte{0x00, 0x00, 0x24},
				devaddr:     []byte{0x48, 0x3a, 0x24, 0x9d},
				rx1droffset: 0x00,
				rx2datarate: 0x00,
				rxdelay:     0x00,
				cflist:      []uint32{8671000, 8673000, 8675000, 8677000, 8679000},
				key:         []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02},
			},
			joinAccept{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
				0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
				key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := New(tt.args.Major, tt.args.appnonce, tt.args.netid, tt.args.devaddr, tt.args.rx1droffset, tt.args.rx2datarate, tt.args.rxdelay, tt.args.cflist, tt.args.key); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("New() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestParse(t *testing.T) {
	type args struct {
		bb  []byte
		key []byte
	}
	tests := []struct {
		name    string
		args    args
		want    JoinAccept
		wantErr bool
	}{
		{"basic", args{bb: []byte{0x20, 0xa3, 0x28, 0x30, 0xdf, 0x17, 0xe2, 0x8a, 0x2a, 0x4c, 0xc9, 0x35, 0x6b, 0x58, 0x71,
			0xb8, 0x94, 0x00, 0xe0, 0x78, 0x4e, 0x1e, 0xcc, 0x10, 0x3f, 0x03, 0x4d, 0xac, 0x6c, 0x8e, 0x1d, 0x7c, 0xb6},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			joinAccept{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
				0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
				key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := Parse(tt.args.bb, tt.args.key)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Parse() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_joinAccept_AppNonce(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			[]byte{0x24, 0x63, 0x61},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.AppNonce(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("joinAccept.AppNonce() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_joinAccept_NetID(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			[]byte{0x00, 0x00, 0x24},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.NetID(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("joinAccept.NetID() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_joinAccept_DevAddr(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			[]byte{0x48, 0x3a, 0x24, 0x9d},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.DevAddr(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("joinAccept.DevAddr() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_joinAccept_DlSettingsRX1DRoffset(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   byte
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			0x00,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.DlSettingsRX1DRoffset(); got != tt.want {
				t.Errorf("joinAccept.DlSettingsRX1DRoffset() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_joinAccept_RxDelay(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   byte
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			0x00,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.RxDelay(); got != tt.want {
				t.Errorf("joinAccept.RxDelay() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_joinAccept_CFlist(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []uint32
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			[]uint32{8671000, 8673000, 8675000, 8677000, 8679000},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.CFlist(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("joinAccept.CFlist() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_joinAccept_MIC(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			[]byte{0x5a, 0x8d, 0x60, 0x3a},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.MIC(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("joinAccept.MIC() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_joinAccept_MType(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   mhdr.MType
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			mhdr.JoinAcceptMessageType,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.MType(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("joinAccept.MType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_joinAccept_Major(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   mhdr.MajorVersion
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			mhdr.LoRaWANR1MajorVersion,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.Major(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("joinAccept.Major() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_joinAccept_ByteArray(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			[]byte{0x20, 0xa3, 0x28, 0x30, 0xdf, 0x17, 0xe2, 0x8a, 0x2a, 0x4c, 0xc9, 0x35, 0x6b, 0x58, 0x71,
				0xb8, 0x94, 0x00, 0xe0, 0x78, 0x4e, 0x1e, 0xcc, 0x10, 0x3f, 0x03, 0x4d, 0xac, 0x6c, 0x8e, 0x1d, 0x7c, 0xb6},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.ByteArray(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("joinAccept.ByteArray() = %v, want %v", hex.EncodeToString(got), hex.EncodeToString(tt.want))
			}
		})
	}
}

func Test_joinAccept_String(t *testing.T) {
	type fields struct {
		bytes []byte
		key   []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		{"basic", fields{bytes: []byte{0x20, 0x61, 0x63, 0x24, 0x24, 0x00, 0x00, 0x9d, 0x24, 0x3a, 0x48, 0x00, 0x00, 0x18, 0x4f, 0x84,
			0xe8, 0x56, 0x84, 0xb8, 0x5e, 0x84, 0x88, 0x66, 0x84, 0x58, 0x6e, 0x84, 0x00, 0x5a, 0x8d, 0x60, 0x3a},
			key: []byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}},
			"JoinAcceptMessageType: AppNonce: 246361; NetID: 000024; DevAddr: 483A249D; RX1DRoffset: 00; RX2Datarate: 00; RxDelay: 00; MIC: 5A8D603A; CFList: [8671000 8673000 8675000 8677000 8679000]",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ja := joinAccept{
				bytes: tt.fields.bytes,
				key:   tt.fields.key,
			}
			if got := ja.String(); got != tt.want {
				t.Errorf("joinAccept.String() = %v, want %v", got, tt.want)
			}
		})
	}
}
