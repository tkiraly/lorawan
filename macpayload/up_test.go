package macpayload

import (
	"reflect"
	"testing"

	"github.com/tkiraly/lorawan/commands"
	"github.com/tkiraly/lorawan/mhdr"
)

func Test_dataUp_ByteArray(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			[]byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x6F, 0x89, 0x5D, 0x98, 0x81, 0x07, 0x14, 0xE3, 0x26, 0x82, 0x95},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := m.ByteArray(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataUp.ByteArray() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_MType(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   mhdr.MType
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x6F, 0x89, 0x5D, 0x98, 0x81, 0x07, 0x14},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			mhdr.UnconfirmedDataUpMessageType,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := m.MType(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataUp.MType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_Major(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   mhdr.MajorVersion
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x6F, 0x89, 0x5D, 0x98, 0x81, 0x07, 0x14},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			mhdr.LoRaWANR1MajorVersion,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := m.Major(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataUp.Major() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_FPort(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	a := uint8(1)
	tests := []struct {
		name   string
		fields fields
		want   *uint8
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			&a,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := *d.FPort(); got != *tt.want {
				t.Errorf("dataUp.FPort() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_FRMPayload(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			[]byte{0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := d.FRMPayload(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataUp.FRMPayload() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_MIC(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			[]byte{0xE3, 0x26, 0x82, 0x95},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := d.MIC(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataUp.MIC() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_String(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			"DataDown! MType: UnconfirmedDataUpMessageType; Major: LoRaWANR1MajorVersion;; FHDRUp: DevAddr: 260413AE; FCnt: 0; ADR: true; ADRACKReq: false; ACK: false; FOptsLen: 0, FOpts: [];; FPort: 1; FRMPayload: 61626364656667; MIC: E3268295",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.String(); got != tt.want {
				t.Errorf("dataUp.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_DevAddr(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			[]byte{0x26, 0x04, 0x13, 0xAE},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.DevAddr(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataUp.DevAddr() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_FCnt(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   uint16
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			0,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.FCnt(); got != tt.want {
				t.Errorf("dataUp.FCnt() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_FOpts(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []commands.Fopter
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.FOpts(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataUp.FOpts() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_ADRACKReq(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.ADRACKReq(); got != tt.want {
				t.Errorf("dataUp.ADRACKReq() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_ADR(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.ADR(); got != tt.want {
				t.Errorf("dataUp.ADR() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_ACK(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.ACK(); got != tt.want {
				t.Errorf("dataUp.ACK() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataUp_FOptsLen(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   uint8
	}{
		{"basic",
			fields{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			0,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataUp{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.FOptsLen(); got != tt.want {
				t.Errorf("dataUp.FOptsLen() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestNewUp(t *testing.T) {
	type args struct {
		mtype      mhdr.MType
		major      mhdr.MajorVersion
		devaddr    []byte
		fcnt       uint16
		fopts      []commands.Fopter
		adr        bool
		ack        bool
		adrackreq  bool
		foptslen   uint8
		fport      *uint8
		frmpayload []byte
		nwkskey    []byte
		appskey    []byte
	}
	a := uint8(1)
	tests := []struct {
		name string
		args args
		want DataUp
	}{
		{"basic",
			args{
				mtype:      mhdr.UnconfirmedDataUpMessageType,
				major:      mhdr.LoRaWANR1MajorVersion,
				devaddr:    []byte{0x26, 0x04, 0x13, 0xAE},
				fcnt:       0,
				fopts:      nil,
				adr:        true,
				ack:        false,
				adrackreq:  false,
				foptslen:   0,
				fport:      &a,
				frmpayload: []byte{0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67},
				nwkskey:    []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey:    []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			dataUp{
				bytes:   []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewUp(tt.args.mtype, tt.args.major, tt.args.devaddr, tt.args.fcnt, tt.args.fopts, tt.args.adr, tt.args.ack, tt.args.adrackreq, tt.args.foptslen, tt.args.fport, tt.args.frmpayload, tt.args.nwkskey, tt.args.appskey); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewUp() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestParseUp(t *testing.T) {
	type args struct {
		p       []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name    string
		args    args
		want    DataUp
		wantErr bool
	}{
		{"basic",
			args{
				p:       []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x6F, 0x89, 0x5D, 0x98, 0x81, 0x07, 0x14, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			dataUp{bytes: []byte{0x40, 0xAE, 0x13, 0x04, 0x26, 0x80, 0x00, 0x00, 0x01, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0xE3, 0x26, 0x82, 0x95},
				nwkskey: []byte{0x99, 0xD5, 0x84, 0x93, 0xD1, 0x20, 0x5B, 0x43, 0xEF, 0xF9, 0x38, 0xF0, 0xF6, 0x6C, 0x33, 0x9E},
				appskey: []byte{0x0A, 0x50, 0x15, 0x24, 0xF8, 0xEA, 0x5F, 0xCB, 0xF9, 0xBD, 0xB5, 0xAD, 0x7D, 0x12, 0x6F, 0x75},
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := ParseUp(tt.args.p, tt.args.nwkskey, tt.args.appskey)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseUp() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ParseUp() = %v, want %v", got, tt.want)
			}
		})
	}
}
