package macpayload

import (
	"reflect"
	"testing"

	"github.com/tkiraly/lorawan/commands"
	"github.com/tkiraly/lorawan/mhdr"
)

func Test_dataDown_ByteArray(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			[]byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0xD8, 0xD8, 0x22, 0xF3, 0x4E, 0x30, 0x6D, 0xD0},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := m.ByteArray(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataDown.ByteArray() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_MType(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   mhdr.MType
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			mhdr.UnconfirmedDataDownMessageType,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := m.MType(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataDown.MType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_Major(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   mhdr.MajorVersion
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			mhdr.LoRaWANR1MajorVersion,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := m.Major(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataDown.Major() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_FPort(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	a := uint8(0x42)
	tests := []struct {
		name   string
		fields fields
		want   *uint8
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			&a,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := *d.FPort(); got != *tt.want {
				t.Errorf("dataDown.FPort() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_FRMPayload(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			[]byte{0x88, 0x88, 0x88, 0x88},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := d.FRMPayload(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataDown.FRMPayload() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_MIC(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			[]byte{0x4E, 0x30, 0x6D, 0xD0},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := d.MIC(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataDown.MIC() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_String(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			"DataDown: MHDR: MType: UnconfirmedDataDownMessageType; Major: LoRaWANR1MajorVersion;; FHDRUp: DevAddr: 49810545; FCnt: 0; ADR: true; FPending: false; ACK: true; FOptsLen: 0, FOpts: []; FPort: 66; FRMPayload: 88888888; MIC: 4E306DD0",
		},
		{"no payload and port",
			fields{
				bytes:   []byte{0xa0, 0x2b, 0xf0, 0x90, 0xa8, 0xa1, 0x07, 0x00, 0x06, 0x25, 0x07, 0x42, 0x83},
				nwkskey: []byte{0x56, 0xAA, 0x4A, 0x88, 0xB9, 0xE7, 0x84, 0x72, 0xD5, 0x00, 0xCB, 0xFD, 0xE9, 0xC0, 0x48, 0x36},
				appskey: []byte{0xC6, 0x68, 0xDC, 0xF1, 0xB5, 0xDE, 0xB3, 0x5B, 0xC1, 0x1B, 0xCF, 0xC7, 0xE4, 0xFB, 0x67, 0xB3},
			},
			"DataDown: MHDR: MType: ConfirmedDataDownMessageType; Major: LoRaWANR1MajorVersion;; FHDRUp: DevAddr: A890F02B; FCnt: 7; ADR: true; FPending: false; ACK: true; FOptsLen: 1, FOpts: [DevStatusReq!]; FPort: none; FRMPayload: ; MIC: 25074283",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.String(); got != tt.want {
				t.Errorf("dataDown.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_DevAddr(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			[]byte{0x49, 0x81, 0x05, 0x45},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.DevAddr(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataDown.DevAddr() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_FCnt(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   uint16
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			0,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.FCnt(); got != tt.want {
				t.Errorf("dataDown.FCnt() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_FOpts(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   []commands.Fopter
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.FOpts(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("dataDown.FOpts() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_FPending(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.FPending(); got != tt.want {
				t.Errorf("dataDown.FPending() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_ADR(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.ADR(); got != tt.want {
				t.Errorf("dataDown.ADR() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_ACK(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.ACK(); got != tt.want {
				t.Errorf("dataDown.ACK() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_dataDown_FOptsLen(t *testing.T) {
	type fields struct {
		bytes   []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name   string
		fields fields
		want   uint8
	}{
		{"basic",
			fields{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			0,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			du := dataDown{
				bytes:   tt.fields.bytes,
				nwkskey: tt.fields.nwkskey,
				appskey: tt.fields.appskey,
			}
			if got := du.FOptsLen(); got != tt.want {
				t.Errorf("dataDown.FOptsLen() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestNewDown(t *testing.T) {
	type args struct {
		mtype      mhdr.MType
		major      mhdr.MajorVersion
		devaddr    []byte
		fcnt       uint16
		fopts      []commands.Fopter
		adr        bool
		ack        bool
		fpending   bool
		foptslen   uint8
		fport      *uint8
		frmpayload []byte
		nwkskey    []byte
		appskey    []byte
	}
	a := uint8(55)
	tests := []struct {
		name string
		args args
		want DataDown
	}{
		{"basic",
			args{
				mtype:      mhdr.UnconfirmedDataDownMessageType,
				major:      mhdr.LoRaWANR1MajorVersion,
				devaddr:    []byte{0x48, 0x52, 0x1F, 0xBD},
				fcnt:       1,
				fopts:      nil,
				adr:        true,
				ack:        false,
				fpending:   false,
				foptslen:   0,
				fport:      &a,
				frmpayload: []byte{0x88, 0x88, 0x88, 0x88},
				nwkskey:    []byte{0x7E, 0x49, 0x1B, 0x08, 0xF3, 0x09, 0xF0, 0x0B, 0xA7, 0xF2, 0xEE, 0x6B, 0x81, 0x69, 0x13, 0x5F},
				appskey:    []byte{0xDC, 0x6F, 0xB6, 0x47, 0x17, 0x47, 0xE1, 0x14, 0x19, 0x0A, 0x58, 0x31, 0x6A, 0xDF, 0x98, 0xAD},
			},
			dataDown{
				bytes:   []byte{0x60, 0xbd, 0x1f, 0x52, 0x48, 0x80, 0x01, 0x00, 0x37, 0x88, 0x88, 0x88, 0x88, 0xdd, 0x43, 0x3c, 0xc6},
				nwkskey: []byte{0x7E, 0x49, 0x1B, 0x08, 0xF3, 0x09, 0xF0, 0x0B, 0xA7, 0xF2, 0xEE, 0x6B, 0x81, 0x69, 0x13, 0x5F},
				appskey: []byte{0xDC, 0x6F, 0xB6, 0x47, 0x17, 0x47, 0xE1, 0x14, 0x19, 0x0A, 0x58, 0x31, 0x6A, 0xDF, 0x98, 0xAD},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewDown(tt.args.mtype, tt.args.major, tt.args.devaddr, tt.args.fcnt, tt.args.fopts, tt.args.adr, tt.args.ack, tt.args.fpending, tt.args.foptslen, tt.args.fport, tt.args.frmpayload, tt.args.nwkskey, tt.args.appskey); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewDown() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestParseDown(t *testing.T) {
	type args struct {
		p       []byte
		nwkskey []byte
		appskey []byte
	}
	tests := []struct {
		name    string
		args    args
		want    DataDown
		wantErr bool
	}{
		{"basic",
			args{
				p:       []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0xD8, 0xD8, 0x22, 0xF3, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			dataDown{
				bytes:   []byte{0x60, 0x45, 0x05, 0x81, 0x49, 0xA0, 0x00, 0x00, 0x42, 0x88, 0x88, 0x88, 0x88, 0x4E, 0x30, 0x6D, 0xD0},
				nwkskey: []byte{0x15, 0x10, 0xEF, 0x39, 0xE8, 0xCD, 0x3F, 0x04, 0xDD, 0xE2, 0x6B, 0x46, 0x31, 0xA9, 0xE9, 0x3B},
				appskey: []byte{0xF0, 0xDC, 0x44, 0xD0, 0x9B, 0xB2, 0xD8, 0xE3, 0x03, 0x85, 0x97, 0x5A, 0xE9, 0x98, 0xBC, 0x4A},
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := ParseDown(tt.args.p, tt.args.nwkskey, tt.args.appskey)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseDown() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ParseDown() = %v, want %v", got, tt.want)
			}
		})
	}
}
